Level(
    id: "f79d2928-aa91-44d8-ac3a-176e991b2c7a",
    name: "Conway's Game of Life",
    description: "
        Conway's Game of Life is a simple cellular automaton made up of an infinite 2D grid of cells. Each cell is either live or dead and each on timestep every cell's state updated.
        
        Your job is to implement the control logic of a cell given the cell's current state (LIVE) and the number if live neighbors it has (N).
        
        • A live cell with <2 neighbors dies
        • A live cell with 3-4 neighbors lives
        • A live cell with >3 neighbors dies
        • A dead cell with 3 neighbors becomes live",
        children: [ ],

    labels: {
        Dynamic(0): "N8",
        Dynamic(1): "N4",
        Dynamic(2): "N2",
        Dynamic(3): "N1",
        Dynamic(4): "LIVE",
    },
    tiles: {
        (0, 5): Emitter( rotation: Down, active: false, id: 0 ),
        (1, 5): Emitter( rotation: Down, active: false, id: 1 ),
        (2, 5): Emitter( rotation: Down, active: false, id: 2 ),
        (3, 5): Emitter( rotation: Down, active: false, id: 3 ),
        (5, 5): Emitter( rotation: Down, active: false, id: 4 ),
        (3, 0): Detector( id: 5 )
    },

    tests: Tests(
        lasers: [ 0, 1, 2, 3, 4 ],
        detectors: [ 5 ],
        display: DisplayConfig(
            emitter_spaces: [ 3 ],
            descriptions: {
                0: "Dead cell with 4 live neighbors stays dead.",
                1: "Live cell with 2 live neighbors lives.",
                2: "Dead cell with 1 live neighbor stays dead.",
                3: "Live cell with 3 live neighbors lives.",
                4: "Dead cell with 6 live neighbors dies.",
                5: "Dead cell with 7 live neighbors stays dead.",
                6: "Dead cell with 3 live neighbors beacomes live.",
                7: "Live cell with no live neighbors dies.",
            }
        ),

        cases: [
            Cycle( lasers: [ false, true,  false, false, false ], detectors: [ [ false ] ] ),
            Cycle( lasers: [ false, false, true,  false, true  ], detectors: [ [ true  ] ] ),
            Cycle( lasers: [ false, false, false, true,  false ], detectors: [ [ false ] ] ),
            Cycle( lasers: [ false, false, true,  true,  true  ], detectors: [ [ true  ] ] ),
            Cycle( lasers: [ false, true,  true,  false, false ], detectors: [ [ false ] ] ),
            Cycle( lasers: [ false, true,  true,  true,  false ], detectors: [ [ false ] ] ),
            Cycle( lasers: [ false, false, true,  true,  false ], detectors: [ [ true  ] ] ),
            Cycle( lasers: [ false, false, false, false, true  ], detectors: [ [ false ] ] ),
        ]
    )
)

// Test cases generated with the following code:
/*
use std::collections::HashSet;
use rand::prelude::*;

fn main() {
    let mut rng = rand::rng();
    let mut seen = HashSet::new();
    while seen.len() < 15 {
        let around = rng.random_range::<u32, _>(0..=8);
        let is_live = rng.random::<bool>();

        if !seen.insert((around, is_live)) {
            continue;
        }

        let next = if is_live {
            matches!(around, 2 | 3)
        } else {
            around == 3
        };

        println!("{around:0>4b}{:b},{next}", is_live as u8);
    }
}
*/
